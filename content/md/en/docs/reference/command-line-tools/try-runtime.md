---
title: try-runtime
description: Command-line reference for using try-runtime to test a specified runtime state against a production snapshot of chain state.
keywords:
  - testing
  - snapshot
  - integration testing
  - production
  - runtime upgrades
  - storage migration
---

The `try-runtime` command-line tool is a verbose testing framework that provides users with the ability to finely tune excutables in a simulated environment before deploying to a live implementation. It takes a snapshot of runtime storage using an [in-memory-externalities](https://paritytech.github.io/substrate/master/sp_state_machine/struct.TestExternalities.html) data structure to store state, which can then be ran with the desired configuration changes offline. With this tool, it is possible to write tests against a snapshot of the runtime state _before_ going to production.


In general, adding the `try-runtime` tool to your runtime is similar to importing pallets.
It involves adding the appropriate dependencies in the correct places and updating the runtime logic to include the `try-runtime` features.

As with pallets, be sure that the appropriate tag or branch for the `try-runtime` tool is being used when adding dependencies to the runtime.



## Add runtime dependencies

1. Open a terminal shell and change to the root directory for the node template.

1. Open the `runtime/Cargo.toml` configuration file in a text editor.

1. Locate the [dependencies] section and note how other pallets are imported.

1. Add the `frame-try-runtime` dependency:
  
   ```toml
   [dependencies]
	 frame-try-runtime = { git = "https://github.com/paritytech/substrate.git", branch = "polkadot-v0.9.28", optional = true }
	 ```

	 Note that you should use the same branch and version information for all of the pallets to ensure that the imported pallets are compatible with each other.
   Using pallets from different branches can result in compiler errors.
   This example illustrates adding the `frame-try-runtime` pallet to the `Cargo.toml` file if the other pallets use `branch = "polkadot-v0.9.28"`.

1. Add the `try-runtime-cli` dependency:

	 ```toml
	 try-runtime-cli = { git = "https://github.com/paritytech/substrate.git", branch = "polkadot-v0.9.28", optional = true }
	 ```

1. Add `frame-try-runtime` to the list of standard features:

    ```toml
		[features]
		default = ["std"]
		std = [
			"codec/std",
			"scale-info/std",
			"frame-try-runtime/std",
			...
		]
		```

1. Add or update `try-runtime` in the `[features]` section in include every pallet in your runtime.
   
	 ```toml
	 try-runtime = [
		 "frame-executive/try-runtime",
		 "frame-try-runtime",
		 "frame-system/try-runtime",
		 "pallet-aura/try-runtime",
		 "pallet-balances/try-runtime",
		 "pallet-nicks/try-runtime",
		 "pallet-grandpa/try-runtime",
		 "pallet-randomness-collective-flip/try-runtime",
		 "pallet-sudo/try-runtime",
		 "pallet-template/try-runtime",
		 "pallet-timestamp/try-runtime",
		 "pallet-transaction-payment/try-runtime",
		]
	```
  
## Basic command usage

The basic syntax for running `try-runtime` commands is:

```shell
cargo run --release --features=try-runtime try-runtime [options] [subcommand]
```

Depending on the subcommand you specify, additional arguments, options, and flags might apply or be required.
To view usage information for a specific `try-runtime` subcommand, specify the subcommand and the `--help` flag.
For example, to see usage information for `try-runtime on-runtime-upgrade`, you can run the following command:

```shell
cargo run --release --features=try-runtime try-runtime on-runtime-upgrade --help
```

## Subcommands

You can use the following subcommands with the `try-runtime` command-line tool.
For reference information and examples that illustrate using these subcommands, select an appropriate command.

| Command | Description
| ------- | -----------
| `on-runtime-upgrade` | Executes the migrations of the local runtime.
| `execute-block` | Executes the given block augainst some state.
| `offchain-worker`| Executes *the offchain worker hooks* of a given block against some state.
| `follow-chain` | Follows the given chain's finalized blocks and applies all of its extrinsics.
| `help`| Displays usage information for try-runtime the specified subcommand.

## Options

You can use the following options with `try-runtime` commands.

| Option | Description
| ------ | -----------
| `--chain <CHAIN_SPEC>` | Specifies the chain specification to use. You can use a predefined chain specification name, such as `dev`, `local`, or `staging` or the path to a file that contains the chain specification, for example, the chain specification generated by using the `build-spec` subcommand.
| `--dev` | Starts the node in development mode in a fresh state. No state is persisted if you run the node using this flag. This option sets `--chain=dev`, `--force-authoring`, `--rpc-cors=all`, `--alice`, and `--tmp` flags, unless explicitly overridden.
| `-d`, `--base-path <path>` | Specifies a custom base path.
| `-l`, `--log <log-pattern>...` | Sets a custom logging filter. The syntax to use is `<log-target>=<level>`, for example `-lsync=debug`. The valid log levels from least to most verbose are `error`, `warn`, `info`, `debug`, and `trace`. By default, all targets log `info` level messages. You can set the global log level with `-l<level>`.
| `--detailed-log-output` | Enables detailed log output, including the log target, log level and thread name. This option is automatically enabled when log level is higher than `info`.
| `--disable-log-color` | Disables log color output.
| `--enable-log-reloading` | Enables feature to dynamically update and reload the log filter. Be aware that enabling this feature can lead to a performance decrease up to factor six or more. Depending on the global logging level the performance decrease changes. The `system_addLogFilter` and `system_resetLogFilter` RPCs will have no effect with this option not being set.
| `--tracing-targets <targets>` | Sets a custom profiling filter. Syntax is the same as for logging: <target>=<level>.
| `--tracing-receiver <receiver>` | Specifies a receiver to process tracing messages.
| `--execution <strategy>` | Determines the execution strategy used by all execution contexts. Valid values are `Native`, `Wasm`, `Both` or `NativeElseWasm`.
| `--wasm-execution <method>` | Specifies the method for executing WebAssembly runtime code. Valid values are `interpreted`, or `compiled`. The default is `Compiled`.
| `--wasm-instantiation-strategy <strategy>` | Specifies the WebAssembly instantiation method to use if `wasm-execution` is set to `compiled`. The default strategy is `pooling-copy-on-write`.
| `--heap-pages <heap_pages>` | Specifies the number of 64KB pages to allocate for WebAssembly execution. The defaults is`sc_service::Configuration.default_heap_pages`.
| `--no-spec-check-panic` | Allows the specification check to issue a warning rather than panic.
| `--state-version <state_version>` | Specifies the state version that is used by the chain. The default is 1.
| `-h, --help` | Displays usage information (use `-h` for a summary).
| `-V, --version` | Displays version information.

## Examples

To use `try-runtime` from the command line, run your node with the `--features=try-runtime` flag.
For example:

```bash
cargo run --release --features=try-runtime try-runtime
```

To view usage information for a specific `try-runtime` subcommand, specify the subcommand and the `--help` flag.
For example:

```bash
cargo run --release --features=try-runtime try-runtime on-runtime-upgrade --help
```

### Setting RPC command-line options

Typically, you use `try-runtime` to prepare for storage migration and runtime upgrades.
However, RPC calls that query storage are computationally expensive.
To prepare a node for testing with `try-runtime`, you should start the node with the following command-line options:

- `--rpc-max-request-size <RPC_MAX_REQUEST_SIZE>` to set the maximum RPC request payload size—in megabytes—to ensure RPC calls that query storage aren't rejected. The default is 15MiB.

- `--rpc-max-response-size <RPC_MAX_RESPONSE_SIZE>` to set the maximum RPC response payload size—in megabytes—to ensure the data retrieved from RPC calls to storage can be returned. The default is 15MiB.

- `--rpc-cors all` to ensure all WebSocket connections can come through.

For example:

```bash
cargo run --release -- \
  --rpc-max-request-size 1000 \
  --rpc-max-response-size 1000 \
  --rpc-cors all \
  --dev
```

### Runtime upgrade

You can use the `on-runtime-upgrade` subcommand to execute against the given runtime state.
For example, you can run `try-runtime` with `on-runtime-upgrade` for a chain running locally with a command like this:

```bash
cargo run --release --features=try-runtime try-runtime on-runtime-upgrade live ws://localhost:9944
```

### Migration testing
  
One of the gems that come only in the `try-runtime` feature flag is the `pre_upgrade` and
`post_upgrade` hooks for `OnRuntimeUpgrade`. This trait is implemented either inside the pallet,
 or manually in a runtime, to define a migration. In both cases, these functions can be added,
 given the right flag:

 ```ignore
 
 #[cfg(feature = try-runtime)]
 fn pre_upgrade() -> Result<Vec<u8>, &'static str> {}

 #[cfg(feature = try-runtime)]
 fn post_upgrade(state: Vec<u8>) -> Result<(), &'static str> {}
 ```

   These hooks allow for the execution of code within `on-runtime-upgrade` command, before
 and after the migration. Moreover, `pre_upgrade` can return a `Vec<u8>` that contains arbitrary
 encoded data (usually some pre-upgrade state), which will be passed to `post_upgrade` after
 upgrading and used for post checking.

You can combine `try-runtime` with [`fork-off-substrate`](https://github.com/maxsam4/fork-off-substrate) to test your chain before production.
Use `try-runtime` to test your chain's migration and its pre and post states.
Then, use `fork-off-substrate` if you want to check that block production continues after the migration.

Always make sure that any migration code is guarded either by `StorageVersion`, or by some custom storage item, so that it is NEVER executed twice, even if the code lives in two consecutive runtimes.

### Execute block

The `execute-block` subcommand executes `core_execute_block` using the given block and the runtime state of the parent block.

### Follow chain

The `follow-chain` subcommand follows a given chain's finalized blocks and applies to all its extrinsics. 
This subcommand allows you to inspect the behavior of a new runtime over a long period of time with real transactions coming as input.

### Offchain worker

The `offchain-worker` subcommand executes `offchainWorkerApi_offchain_worker` against the given runtime state.
For example, you can use `try-runtime` to re-execute code from the `ElectionProviderMultiPhase` offchain worker on `localhost:9944` with a command like this:

```bash
cargo run -- --release \
   --features=try-runtime \
   try-runtime \
   --execution Wasm \
   --wasm-execution Compiled \
   offchain-worker \
   --header-at 0x491d09f313c707b5096650d76600f063b09835fd820e2916d3f8b0f5b45bec30 \
   live \
   -b 0x491d09f313c707b5096650d76600f063b09835fd820e2916d3f8b0f5b45bec30 \
   -m ElectionProviderMultiPhase \
   --uri wss://localhost:9944
```

You can run the migrations of the local runtime on the state of SomeChain with a command like this:

```bash
RUST_LOG=runtime=trace,try-runtime::cli=trace,executor=trace \
   cargo run try-runtime \
   --execution Native \
   --chain somechain-dev \
   on-runtime-upgrade \
   live \
   --uri wss://rpc.polkadot.io
```

You can run `try-runtime` against the state for a specific block number with a command like this:

```bash
RUST_LOG=runtime=trace,try-runtime::cli=trace,executor=trace \
   cargo run try-runtime \
   --execution Native \
   --chain dev \
   --no-spec-name-check \
   on-runtime-upgrade \
   live \
   --uri wss://rpc.polkadot.io \
   --at <block-hash>
```

If the state of a particular pallet is sufficient for your test (e.g. a storage migration), you can use the `pallet` option of the `live` subcommand. Only the state/storages of that pallet will be uploaded. The option `--no-spec-check-panic` might be useful to not panic if local runtime spec name/version is not equal to the uri source:

```bash
RUST_LOG=runtime=trace,try-runtime::cli=trace,executor=trace \
   cargo run try-runtime \
   --execution Native \
   --chain somechain-dev \
   --no-spec-check-panic \
   on-runtime-upgrade \
   live \
   --uri wss://rpc.polkadot.io \
   --pallet NominationPools
```

Notice that this command requires the `--no-spec-name-check` command-line option.

## Where to go next

- [Storage keys](/build/runtime-storage#storage-value-keys)
- [OnRuntimeUpgrade](https://paritytech.github.io/substrate/master/frame_support/traits/trait.OnRuntimeUpgrade.html) 
- [try-runtime-upgrade](https://paritytech.github.io/substrate/master/frame_executive/struct.Executive.html#method.try_runtime_upgrade)
  
